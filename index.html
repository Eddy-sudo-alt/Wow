<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Schiffe auf Wasser — Kreisbahn (Top-Down)</title>
<style>
  :root{
    --bg:#e8f9ff; --water1:#bfe8ff; --water2:#5fb0e6; --ui:#ffffffcc; --muted:#123;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Arial;color:var(--muted);background:linear-gradient(180deg,#f8feff,#e8f9ff);}
  header{padding:12px 16px}
  h1{margin:0;font-size:18px}
  .hint{font-size:13px;margin:4px 0 0 0;color:#345}
  .controls{display:flex;gap:8px;padding:10px 16px;align-items:center;flex-wrap:wrap}
  button{background:var(--ui);border:0;padding:8px 12px;border-radius:10px;box-shadow:0 6px 18px rgba(20,50,80,0.06);cursor:pointer}
  .stage-wrap{display:flex;align-items:center;justify-content:center;padding:10px;flex:1}
  .stage{width:100%;max-width:980px;height:74vh;min-height:420px;border-radius:18px;box-shadow:0 14px 40px rgba(20,40,80,0.08);overflow:hidden;position:relative;background:transparent}
  canvas{display:block;width:100%;height:100%}
  footer{padding:10px 16px;font-size:13px;color:#445;text-align:center}
  .panel{position:absolute;left:14px;top:14px;background:var(--ui);padding:8px 10px;border-radius:10px;backdrop-filter:blur(6px);box-shadow:0 4px 12px rgba(0,0,0,0.06)}
  .small{font-size:13px}
  @media (max-width:640px){ h1{font-size:16px} .controls{padding:8px} }
</style>
</head>
<body>
<header>
  <h1>Schiffe auf Wasser — Top-Down Kreisbahn</h1>
  <p class="hint">Stilisiertes Spielzeug-Look • Boote kreisen automatisch • Tippe/Klicke = Boot hinzufügen • Ziehen zum lenken</p>
</header>

<div class="controls">
  <button id="add">+ Boot</button>
  <button id="addLily">+ Seerose</button>
  <button id="addFish">+ Fisch</button>
  <button id="calm">Beruhigen</button>
  <div style="flex:1"></div>
  <button id="reset">Zurücksetzen</button>
</div>

<div class="stage-wrap">
  <div class="stage" id="stage" role="application" aria-label="Teich mit kreisender Bootsbahn">
    <canvas id="c"></canvas>
    <div class="panel small" id="info">Boote: 0 • Seerosen: 0 • Fische: 0</div>
  </div>
</div>

<footer>Tipp: A für Boot, L für Seerose, F für Fisch — Kein Wettbewerb, nur Entspannung.</footer>

<script>
/* --- Top-Down Kreisbahn — Stylisiert, single-file --- */
/* Design: oval path; boats follow angle along path; slight sway; drag to adjust angle; add boats; autosave */

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let DPR = Math.max(1, devicePixelRatio || 1);
function resize(){
  DPR = Math.max(1, devicePixelRatio || 1);
  canvas.width = canvas.clientWidth * DPR;
  canvas.height = canvas.clientHeight * DPR;
}
window.addEventListener('resize', ()=>{ resize(); draw(); });
resize();

/* World */
const world = {
  time: 0,
  boats: [],
  lilies: [],
  fish: [],
  calmFactor: 1,
  speedFactor: 1,
  center: {x:0,y:0}, // px (device coords)
  rx: 260, ry: 140, // radii of oval path (in CSS px, scaled by DPR when drawing)
};

/* helpers */
const rand = (a,b)=> Math.random()*(b-a)+a;
const clamp = (v,a,b)=> Math.max(a,Math.min(b,v));

/* Boat model: angle (rad) along oval, radius offset, speed */
class Boat {
  constructor(angle, color='#ff9f6a', size=28){
    this.angle = angle; // radians
    this.offset = rand(-12,12); // orthogonal offset from path
    this.speed = rand(0.18,0.36); // radians per second baseline
    this.color = color; this.size = size;
    this.dragging = false;
    this.id = 'b_'+Math.random().toString(36).slice(2,9);
  }
  // compute position in CSS pixels (not DPR)
  pos(){
    const cx = world.center.x;
    const cy = world.center.y;
    const rx = world.rx; const ry = world.ry;
    const a = this.angle;
    // base ellipse point
    let x = cx + rx*Math.cos(a);
    let y = cy + ry*Math.sin(a);
    // apply small normal offset outward (normal vector to ellipse)
    // normal approximated by (cos/a, sin*b/a) scaled
    const nx = Math.cos(a); const ny = Math.sin(a);
    x += this.offset * (nx);
    y += this.offset * (ny);
    return {x, y};
  }
  update(dt){
    if(!this.dragging){
      // advance angle
      // speed slightly modulated by calmFactor and noise
      const wobble = Math.sin(world.time*1.5 + (this.id.charCodeAt(2)||0))*0.03;
      this.angle += (this.speed * (0.6 + 0.4*world.calmFactor) + wobble*0.05) * dt * world.speedFactor;
      // small random drift of offset
      this.offset += Math.sin(world.time*0.7 + this.angle*2)*0.02;
      this.offset = clamp(this.offset, -24, 24);
    }
  }
  // draw stylized top-down boat (toy-like)
  draw(ctx){
    const p = this.pos();
    const s = this.size * DPR;
    ctx.save();
    ctx.translate(p.x*DPR, p.y*DPR);
    // rotation: tangent direction on ellipse: derivative -> angle tangent = atan2(ry*cos, -rx*sin) approx
    const rx = world.rx, ry = world.ry;
    const a = this.angle;
    const tx = -rx*Math.sin(a); const ty = ry*Math.cos(a);
    const rot = Math.atan2(ty, tx);
    ctx.rotate(rot);
    // shadow / subtle
    ctx.beginPath();
    ctx.ellipse(0, s*0.14, s*0.8, s*0.35, 0, 0, Math.PI*2);
    ctx.fillStyle = "rgba(0,0,0,0.08)"; ctx.fill();
    // hull
    ctx.beginPath();
    ctx.moveTo(-s*0.6, 0);
    ctx.quadraticCurveTo(0, s*0.7, s*0.6, 0);
    ctx.lineTo(s*0.5, s*0.22); ctx.lineTo(-s*0.5, s*0.22);
    ctx.closePath();
    ctx.fillStyle = this.color; ctx.fill();
    // little deck white stripe
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.fillRect(-s*0.22, -s*0.05, s*0.44, s*0.14);
    ctx.restore();
  }
}

/* Lily */
class Lily {
  constructor(x,y,size=28){ this.x=x; this.y=y; this.size=size; this.id='l_'+Math.random().toString(36).slice(2,9); }
  draw(ctx){
    ctx.save();
    ctx.translate(this.x*DPR, this.y*DPR);
    const s=this.size*DPR;
    ctx.beginPath(); ctx.ellipse(0,0,s*1.1,s*0.6,0,0,Math.PI*2); ctx.fillStyle='#2f9b5a'; ctx.fill();
    ctx.beginPath();
    for(let i=0;i<5;i++){
      const a = i*(Math.PI*2/5);
      ctx.ellipse(Math.cos(a)*s*0.16, Math.sin(a)*s*0.16 - s*0.06, s*0.12, s*0.07, a, 0, Math.PI*2);
    }
    ctx.fillStyle='#fff7e9'; ctx.fill();
    ctx.restore();
  }
}

/* Fish (decorative) */
class Fish {
  constructor(x,y,size=12,color='#8fd8a3'){ this.x=x; this.y=y; this.size=size; this.color=color; this.phase=rand(0,Math.PI*2); }
  draw(ctx){
    ctx.save(); ctx.translate(this.x*DPR, this.y*DPR);
    const s=this.size*DPR;
    ctx.beginPath(); ctx.ellipse(0,0,s*0.9,s*0.5,0,0,Math.PI*2); ctx.fillStyle=this.color; ctx.fill();
    ctx.beginPath(); ctx.moveTo(-s*0.9,0); ctx.lineTo(-s*1.3,-s*0.32); ctx.lineTo(-s*1.3,s*0.32); ctx.closePath(); ctx.fill();
    ctx.restore();
  }
}

/* initialize center & path based on canvas size (CSS pixels) */
function setPathParams(){
  const rect = canvas.getBoundingClientRect();
  world.center.x = rect.width * 0.5;
  world.center.y = rect.height * 0.52;
  // radii scale with smaller dimension
  const minDim = Math.min(rect.width, rect.height);
  world.rx = clamp(minDim*0.36, 120, 420);
  world.ry = clamp(minDim*0.18, 70, 260);
}
setPathParams();

/* drawing */
function draw(){
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);
  setPathParams();
  // background plain
  // draw rounded pond border & fill the water inside (oval)
  ctx.save();
  // pond background (ground)
  ctx.fillStyle = '#dff7e6';
  ctx.fillRect(0,0,w,h);
  // water fill
  ctx.beginPath();
  ctx.ellipse(world.center.x*DPR, world.center.y*DPR, world.rx*DPR+20*DPR, world.ry*DPR+20*DPR, 0, 0, Math.PI*2);
  const g = ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0, '#e9fbff'); g.addColorStop(0.5, '#bfe8ff'); g.addColorStop(1, '#66aee0');
  ctx.fillStyle = g; ctx.fill();
  // inner water surface (slightly smaller)
  ctx.beginPath();
  ctx.ellipse(world.center.x*DPR, world.center.y*DPR, world.rx*DPR, world.ry*DPR, 0, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(255,255,255,0.02)'; ctx.fill();
  // border
  ctx.lineWidth = 6*DPR; ctx.strokeStyle = 'rgba(0,0,0,0.06)';
  ctx.stroke();
  ctx.restore();

  // draw faint wave lines along the path to suggest flow
  ctx.save();
  ctx.lineWidth = 2*DPR; ctx.strokeStyle = 'rgba(255,255,255,0.35)';
  for(let i=0;i<10;i++){
    ctx.beginPath();
    const phase = i*0.6 + world.time*0.6;
    for(let t=0;t<=Math.PI*2+0.01;t+=0.04){
      const rx = world.rx*(1 - 0.02*i);
      const ry = world.ry*(1 - 0.02*i);
      const x = world.center.x + rx*Math.cos(t) + Math.sin(phase + t*1.8)*((i+1)*0.6);
      const y = world.center.y + ry*Math.sin(t) + Math.cos(phase + t*1.3)*((i+1)*0.3);
      if(t===0) ctx.moveTo(x*DPR, y*DPR); else ctx.lineTo(x*DPR, y*DPR);
    }
    ctx.stroke();
  }
  ctx.restore();

  // draw lilies
  world.lilies.forEach(l => l.draw(ctx));
  // draw fish under boats (smaller)
  world.fish.forEach(f => f.draw(ctx));
  // draw boats sorted by y for simple layering
  const sorted = [...world.boats].sort((a,b)=> a.pos().y - b.pos().y);
  sorted.forEach(b => b.draw(ctx));
}

/* update loop */
let last = performance.now();
function frame(now){
  const dt = Math.min(0.05, (now-last)/1000);
  last = now;
  world.time += dt;
  // update boats
  world.boats.forEach(b => b.update(dt));
  // small gentle fish movement (animate by shift)
  world.fish.forEach((f,i)=>{ f.x += Math.sin(world.time*1.5 + i)*0.02; f.y += Math.cos(world.time*1.9 + i)*0.015; });
  draw();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

/* interactions: add, drag, pick */
function addBoat(angle=null){
  // if angle null, place at random around circle
  const a = (angle === null) ? rand(0, Math.PI*2) : angle;
  const colors = ['#ff9f6a','#ffd66b','#8fd8a3','#9fb7ff','#c79bff'];
  const b = new Boat(a, colors[Math.floor(Math.random()*colors.length)], 26 + Math.random()*12);
  world.boats.push(b); updateInfo(); save();
  return b;
}
function addLily(){
  // choose a point on water not overlapping boats
  const t = rand(0,Math.PI*2);
  const p = ellipticPoint(t, 0);
  const l = new Lily(p.x, p.y, 18 + Math.random()*16);
  world.lilies.push(l); updateInfo(); save();
}
function addFish(){
  const t = rand(0,Math.PI*2);
  const p = ellipticPoint(t, 0.3);
  const f = new Fish(p.x, p.y, 8 + Math.random()*10, ['#8fd8a3','#9fb7ff','#ffb6c2'][Math.floor(Math.random()*3)]);
  world.fish.push(f); updateInfo(); save();
}

function ellipticPoint(angle, offsetNorm=0){
  // returns {x,y} css px for angle and offset normalized -1..1 (multiplies by offset range)
  const cx = world.center.x, cy = world.center.y;
  const rx = world.rx, ry = world.ry;
  const x = cx + rx*Math.cos(angle);
  const y = cy + ry*Math.sin(angle);
  // offset outward normal simple
  const nx = Math.cos(angle), ny = Math.sin(angle);
  const off = offsetNorm * 20;
  return { x: x + nx*off, y: y + ny*off };
}

/* pointer interactions */
let pointerId = null, picked = null;
function toLocal(e){
  const r = canvas.getBoundingClientRect();
  let cx, cy;
  if(e.touches && e.touches[0]){ cx = e.touches[0].clientX; cy = e.touches[0].clientY; }
  else { cx = e.clientX; cy = e.clientY; }
  return { x: cx - r.left, y: cy - r.top };
}
function pickBoatAt(x,y){
  let best=null, bd=9999;
  for(const b of world.boats){
    const p = b.pos();
    const dx = p.x - x, dy = p.y - y, d = Math.hypot(dx,dy);
    if(d < Math.max(20, b.size*0.9) && d < bd){ best = b; bd = d; }
  }
  return best;
}
canvas.addEventListener('pointerdown', (ev)=>{
  canvas.setPointerCapture(ev.pointerId);
  pointerId = ev.pointerId;
  const pos = toLocal(ev);
  const b = pickBoatAt(pos.x, pos.y);
  if(b){
    picked = b; b.dragging = true;
  } else {
    // add a boat at nearest angle
    const a = angleFromPoint(pos.x, pos.y);
    addBoat(a);
  }
});
canvas.addEventListener('pointermove', (ev)=>{
  if(pointerId !== ev.pointerId) return;
  const pos = toLocal(ev);
  if(picked){
    // convert pointer to nearest angle along ellipse and set boat.angle and offset
    const a = angleFromPoint(pos.x, pos.y);
    picked.angle = a;
    // offset: distance from ellipse centerline measured along normal
    const eps = ellipseDistanceToPoint(a, pos.x, pos.y);
    picked.offset = clamp(eps, -30, 30);
  }
});
canvas.addEventListener('pointerup', (ev)=>{
  if(pointerId !== ev.pointerId) return;
  canvas.releasePointerCapture(ev.pointerId);
  if(picked){ picked.dragging = false; picked = null; save(); }
  pointerId = null;
});

/* geometry helpers */
function angleFromPoint(x,y){
  // rough inverse: find angle that maps to closest ellipse point
  // use atan2 relative to center as starting guess
  const dx = x - world.center.x, dy = y - world.center.y;
  return Math.atan2(dy/world.ry, dx/world.rx);
}
function ellipseDistanceToPoint(angle, x, y){
  // compute shortest radial distance from point to ellipse boundary along normal approx
  const px = world.center.x + world.rx*Math.cos(angle);
  const py = world.center.y + world.ry*Math.sin(angle);
  const dx = x - px, dy = y - py;
  // project onto normal (cos,sin)
  const nx = Math.cos(angle), ny = Math.sin(angle);
  return dx*nx + dy*ny;
}

/* UI handlers */
document.getElementById('add').addEventListener('click', ()=> addBoat());
document.getElementById('addLily').addEventListener('click', ()=> addLily());
document.getElementById('addFish').addEventListener('click', ()=> addFish());
document.getElementById('calm').addEventListener('click', ()=>{
  world.calmFactor = 0.2; setTimeout(()=> world.calmFactor = 1, 1200);
});
document.getElementById('reset').addEventListener('click', ()=>{
  if(confirm('Alles zurücksetzen?')){ world.boats=[]; world.lilies=[]; world.fish=[]; save(); updateInfo(); }
});

/* keyboard shortcuts */
window.addEventListener('keydown',(e)=>{
  if(e.key==='a') addBoat();
  if(e.key==='l') addLily();
  if(e.key==='f') addFish();
});

/* status and save/load */
const infoEl = document.getElementById('info');
function updateInfo(){ infoEl.textContent = `Boote: ${world.boats.length} • Seerosen: ${world.lilies.length} • Fische: ${world.fish.length}`; }
function save(){
  try{
    const s = {
      boats: world.boats.map(b=>({angle:b.angle,offset:b.offset,color:b.color,size:b.size})),
      lilies: world.lilies.map(l=>({x:l.x,y:l.y,size:l.size})),
      fish: world.fish.map(f=>({x:f.x,y:f.y,size:f.size,color:f.color}))
    };
    localStorage.setItem('kreisboot_v1', JSON.stringify(s));
  }catch(e){}
}
function load(){
  try{
    const raw = localStorage.getItem('kreisboot_v1'); if(!raw) return;
    const s = JSON.parse(raw);
    world.boats = []; world.lilies = []; world.fish = [];
    if(s.boats) s.boats.forEach(o => { const b = new Boat(o.angle, o.color, o.size); b.offset = o.offset||0; world.boats.push(b); });
    if(s.lilies) s.lilies.forEach(o => world.lilies.push(new Lily(o.x,o.y,o.size)));
    if(s.fish) s.fish.forEach(o => world.fish.push(new Fish(o.x,o.y,o.size,o.color)));
    updateInfo();
  }catch(e){}
}
load();
if(world.boats.length===0){
  // seed a few boats
  addBoat(0.1); addBoat(2.3); addBoat(4.1);
}

/* autosave */
setInterval(()=> save(), 5000);
function updateInfoLoop(){ updateInfo(); requestAnimationFrame(updateInfoLoop); }
updateInfoLoop();

/* final: expose to console */
window.kreisBoot = { addBoat, addLily, addFish, save, load };

/* start animation */
requestAnimationFrame(frame);
</script>
</body>
</html>