<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Wasserspaß — Bötchen</title>
<style>
  :root{
    --bg:#e9f6ff;
    --water-top:#9fd9ff;
    --water-bottom:#5fb0e6;
    --panel: rgba(255,255,255,0.85);
    --accent:#ffb86b;
    --muted:#556;
    --glass: rgba(255,255,255,0.6);
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:var(--muted);}
  body{display:flex;flex-direction:column;background:linear-gradient(180deg,var(--bg),#dff3ff 40%);}
  header{padding:12px 16px;display:flex;align-items:center;gap:12px;}
  h1{font-size:16px;margin:0}
  p.hint{margin:0;font-size:12px;color:#445;opacity:0.9}
  .controls{
    margin:8px 16px;display:flex;gap:8px;align-items:center;
  }
  button{
    background:var(--panel);border:1px solid rgba(0,0,0,0.05);
    padding:8px 12px;border-radius:10px;font-size:14px;
    box-shadow:0 1px 4px rgba(0,0,0,0.06);
  }
  button.secondary{background:transparent;border:1px solid rgba(0,0,0,0.06);}
  #container{flex:1;display:flex;align-items:center;justify-content:center;padding:8px;}
  .stage{
    width:100%;max-width:900px;height:70vh;min-height:360px;border-radius:18px;overflow:hidden;
    box-shadow: 0 8px 30px rgba(30,50,80,0.08);position:relative;background:linear-gradient(#fff0, rgba(0,0,0,0.02));
  }
  canvas{display:block;width:100%;height:100%;}
  .ui-bottom{position:absolute;left:12px;right:12px;bottom:12px;display:flex;justify-content:space-between;align-items:center;gap:8px;pointer-events:none}
  .panel{pointer-events:auto;background:var(--glass);padding:8px 10px;border-radius:12px;backdrop-filter:blur(6px);display:flex;gap:8px;align-items:center;}
  .stat{font-size:13px;color:#123;}
  .small{font-size:12px;color:#234}
  footer{padding:10px 16px;font-size:12px;color:#556;text-align:center}
  /* boat cursor */
  .grabbing { cursor: grabbing; }
  @media (max-width:640px){
    h1{font-size:14px}
    .controls{flex-wrap:wrap}
  }
</style>
</head>
<body>
<header>
  <div>
    <h1>Wasserspaß — kleine Bötchen</h1>
    <p class="hint">Tippe/ziehe ein Boot, füge neue Boote hinzu, spiel mit Wind oder beruhige das Wasser.</p>
  </div>
</header>

<div class="controls">
  <button id="addBoat">+ Boot hinzufügen</button>
  <button id="calm" class="secondary">Wasser beruhigen</button>
  <button id="wind" class="secondary">Kurz Wind</button>
  <div style="flex:1"></div>
  <div class="panel">
    <div class="stat" id="boatCount">Boote: 0</div>
    <div style="width:10px"></div>
    <div class="small">Berührung/freigeben, um Boote zu platzieren</div>
  </div>
</div>

<div id="container">
  <div class="stage" id="stage" role="application" aria-label="Entspannendes Wasser mit Booten">
    <canvas id="c"></canvas>
    <div class="ui-bottom">
      <div class="panel small">Schau dir die Wellen an — entspann dich.</div>
      <div class="panel small" id="fps">— fps</div>
    </div>
  </div>
</div>

<footer>Kein Wettbewerb • Nur Entspannung • Für Touch & Desktop</footer>

<script>
/* --- Setup --- */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', {alpha:true});
let DPR = Math.max(1, devicePixelRatio || 1);
function resize(){
  DPR = Math.max(1, devicePixelRatio || 1);
  canvas.width = canvas.clientWidth * DPR;
  canvas.height = canvas.clientHeight * DPR;
}
window.addEventListener('resize', resize);
resize();

/* --- World parameters --- */
const world = {
  time: 0,
  current: 0.12, // base horizontal current speed (px per second scaled)
  wind: 0,
  calmFactor: 1,
  waveAmp: 10,
  waveFreq: 0.008,
  boats: []
};

/* --- Boat class --- */
class Boat {
  constructor(x, y, color='#ff9f6a', size=36){
    this.x = x; this.y = y;
    this.vx = (Math.random()-0.5)*0.01;
    this.vy = 0;
    this.size = size;
    this.color = color;
    this.angle = 0;
    this.dragging = false;
    this.id = Math.random().toString(36).slice(2,9);
    this.floatPhase = Math.random()*Math.PI*2;
  }
  draw(ctx, t){
    const s = this.size;
    ctx.save();
    ctx.translate(this.x*DPR, this.y*DPR);
    ctx.rotate(this.angle);
    // hull
    ctx.beginPath();
    ctx.moveTo(-s*0.6*DPR, 0);
    ctx.quadraticCurveTo(0, s*0.6*DPR, s*0.6*DPR, 0);
    ctx.lineTo(s*0.6*DPR, s*0.25*DPR);
    ctx.lineTo(-s*0.6*DPR, s*0.25*DPR);
    ctx.closePath();
    ctx.fillStyle = this.color;
    ctx.fill();
    // mast
    ctx.beginPath();
    ctx.moveTo(0, -s*0.7*DPR);
    ctx.lineTo(0, -s*0.1*DPR);
    ctx.strokeStyle = 'rgba(255,255,255,0.95)';
    ctx.lineWidth = Math.max(1, 2*DPR);
    ctx.stroke();
    // sail
    ctx.beginPath();
    ctx.moveTo(0, -s*0.6*DPR);
    ctx.lineTo(s*0.25*DPR, -s*0.28*DPR);
    ctx.lineTo(0, -s*0.28*DPR);
    ctx.closePath();
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.fill();
    ctx.restore();
  }
  update(dt, stageW, stageH){
    if(!this.dragging){
      // gentle drift with world current + wind
      const speed = (world.current + world.wind*0.8) * (this.size*0.02) * DPR;
      this.vx += speed * dt * 0.06;
      // some random sway
      this.vx += (Math.sin((world.time+this.floatPhase)*0.8)+ (Math.random()-0.5)*0.2)*0.0004;
      // vertical bobbing from waves
      const waveY = getWaveHeight(this.x) ;
      const targetY = stageH*0.45 + waveY;
      // relax toward wave Y
      this.vy += (targetY - this.y) * 0.02;
      this.vy *= 0.98;
      // angle follows small tilt
      this.angle = Math.atan2(this.vy, this.vx||0.001)*0.05;
      // update positions
      this.x += this.vx * dt * 60 / DPR;
      this.y += this.vy * dt * 60 / DPR;
      // world wrapping horizontally
      if(this.x < -50) this.x = stageW + 50;
      if(this.x > stageW + 50) this.x = -50;
      // clamp vertical a bit
      this.y = Math.max(0, Math.min(stageH - 10, this.y));
      // damp velocities
      this.vx *= 0.995;
    }
  }
}

/* --- Waves --- */
function getWaveHeight(x){
  // x in pixels in canvas coordinates (not DPR-scaled)
  // combine two sines for organic movement
  return world.waveAmp * world.calmFactor * (
    Math.sin((x + world.time*40) * world.waveFreq) * 0.9 +
    Math.sin((x*0.6 + world.time*20) * world.waveFreq*1.4) * 0.5
  );
}

/* --- Draw scene --- */
let last = performance.now();
let fpsEl = document.getElementById('fps');
function frame(now){
  const dt = Math.min(0.05, (now - last)/1000);
  last = now;
  world.time += dt;
  update(dt);
  draw();
  if(fpsEl && typeof now === 'number'){
    fpsEl.textContent = Math.round(1/dt) + ' fps';
  }
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

function update(dt){
  // wind decays
  world.wind *= 0.98;
  // update boats
  const rect = canvas.getBoundingClientRect();
  const stageW = rect.width;
  const stageH = rect.height;
  world.boats.forEach(b => b.update(dt, stageW, stageH));
}

function draw(){
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);
  // background sky subtle gradient
  const skyGrad = ctx.createLinearGradient(0,0,0,h*0.6);
  skyGrad.addColorStop(0, '#ffffff');
  skyGrad.addColorStop(1, '#e6f7ff');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0,0,w,h);
  // water area: draw layered waves
  const rect = canvas.getBoundingClientRect();
  const stageW = rect.width * DPR;
  const stageH = rect.height * DPR;
  const waterTop = stageH*0.35;
  // water body
  const g = ctx.createLinearGradient(0, waterTop, 0, stageH);
  g.addColorStop(0, '#bfe8ff');
  g.addColorStop(1, '#5fb0e6');
  ctx.fillStyle = g;
  ctx.fillRect(0, waterTop, stageW, stageH - waterTop);
  // draw wave surface line
  ctx.lineWidth = 2 * DPR;
  ctx.strokeStyle = 'rgba(255,255,255,0.45)';
  ctx.beginPath();
  for(let px=0; px<=stageW; px+=6*DPR){
    const wx = px / DPR;
    const y = waterTop + getWaveHeight(wx);
    if(px===0) ctx.moveTo(px, y);
    else ctx.lineTo(px, y);
  }
  ctx.stroke();
  // subtle reflections: draw translucent lines
  ctx.globalAlpha = 0.35;
  ctx.lineWidth = 1*DPR;
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.beginPath();
  for(let px=0; px<=stageW; px+=20*DPR){
    const wx = px / DPR;
    const y = waterTop + getWaveHeight(wx) + 6*DPR;
    if(px===0) ctx.moveTo(px, y);
    else ctx.lineTo(px, y);
  }
  ctx.stroke();
  ctx.globalAlpha = 1;
  // draw boats (sorted by y for layering)
  const boatsSorted = [...world.boats].sort((a,b)=>a.y-b.y);
  boatsSorted.forEach(b => b.draw(ctx, world.time));
}

/* --- Interaction: pointer/touch --- */
let pointerId = null;
let picked = null;
function toLocalCoords(e){
  const rect = canvas.getBoundingClientRect();
  let clientX, clientY;
  if(e.touches && e.touches[0]){
    clientX = e.touches[0].clientX;
    clientY = e.touches[0].clientY;
  } else {
    clientX = e.clientX;
    clientY = e.clientY;
  }
  const x = (clientX - rect.left);
  const y = (clientY - rect.top);
  return {x, y};
}
function pickBoatAt(x,y){
  // pick nearest within radius
  let best = null; let bestD = 9999;
  for(const b of world.boats){
    const dx = b.x - x;
    const dy = b.y - y;
    const d = Math.hypot(dx,dy);
    if(d < Math.max(28, b.size*0.9) && d < bestD){
      best = b; bestD = d;
    }
  }
  return best;
}

canvas.addEventListener('pointerdown', (ev)=>{
  canvas.setPointerCapture(ev.pointerId);
  pointerId = ev.pointerId;
  const pos = toLocalCoords(ev);
  const b = pickBoatAt(pos.x, pos.y);
  if(b){
    picked = b;
    b.dragging = true;
    b.vx = 0; b.vy = 0;
    canvas.classList.add('grabbing');
  } else {
    // create a boat where tapped
    addBoatAt(pos.x, pos.y);
  }
});
canvas.addEventListener('pointermove', (ev)=>{
  if(pointerId !== ev.pointerId) return;
  if(picked){
    const pos = toLocalCoords(ev);
    picked.x = pos.x;
    picked.y = pos.y;
  }
});
canvas.addEventListener('pointerup', (ev)=>{
  if(pointerId !== ev.pointerId) return;
  canvas.releasePointerCapture(ev.pointerId);
  if(picked){
    // give flick momentum based on last pointer velocity approximated
    picked.dragging = false;
    picked.vx = (Math.random()-0.5)*0.2; // small kick
    picked.vy = (Math.random()-0.5)*0.1;
    picked = null;
    canvas.classList.remove('grabbing');
  }
  pointerId = null;
});

/* Support older touch events fallback */
canvas.addEventListener('touchstart', (e)=>{ if(e.touches.length===1){} }, {passive:false});

/* --- Controls --- */
const addBtn = document.getElementById('addBoat');
const calmBtn = document.getElementById('calm');
const windBtn = document.getElementById('wind');
const boatCountEl = document.getElementById('boatCount');

function addBoatAt(x=null,y=null){
  const rect = canvas.getBoundingClientRect();
  const w=rect.width, h=rect.height;
  const posX = x===null ? (Math.random()*w) : x;
  const posY = y===null ? (h*0.45 + (Math.random()-0.5)*40) : y;
  const colors = ['#ff9f6a','#ffd66b','#8fd8a3','#9fb7ff','#c79bff'];
  const b = new Boat(posX, posY, colors[Math.floor(Math.random()*colors.length)], 36 + Math.random()*12);
  world.boats.push(b);
  updateBoatCount();
}
addBtn.addEventListener('click', ()=> addBoatAt());
calmBtn.addEventListener('click', ()=>{
  // reduce wave amplitude briefly
  world.calmFactor = 0.2;
  setTimeout(()=> world.calmFactor = 1, 1200);
});
windBtn.addEventListener('click', ()=>{
  world.wind += (Math.random()>0.5?1:-1) * (0.35 + Math.random()*0.6);
  // gentle gust ends by decay automatically
});

/* initial boats */
for(let i=0;i<3;i++) addBoatAt();

function updateBoatCount(){
  boatCountEl.textContent = 'Boote: ' + world.boats.length;
}
updateBoatCount();

/* --- simple autosave state to localStorage so it feels familiar on reload --- */
function saveState(){
  try{
    const s = world.boats.map(b=>({x:b.x,y:b.y,size:b.size,color:b.color}));
    localStorage.setItem('boats_state_v1', JSON.stringify(s));
  }catch(e){}
}
function loadState(){
  try{
    const raw = localStorage.getItem('boats_state_v1');
    if(!raw) return;
    const arr = JSON.parse(raw);
    world.boats = arr.map(o => new Boat(o.x,o.y,o.color,o.size));
    updateBoatCount();
  }catch(e){}
}
window.addEventListener('beforeunload', saveState);
loadState();

/* --- gentle autosave every 6s --- */
setInterval(saveState, 6000);

/* allow dragging on small devices with touchstart fallback */
canvas.addEventListener('mousedown', ()=>{});
canvas.addEventListener('touchstart',(e)=>{
  if(e.touches.length===1){
    // let pointer events handle it on modern devices; prevent scrolling only if touching canvas
    e.preventDefault();
  }
},{passive:false});

/* keyboard support for accessibility — add/remove boats */
window.addEventListener('keydown', (e)=>{
  if(e.key === 'a') addBoatAt();
  if(e.key === 'c') { world.calmFactor = 0.2; setTimeout(()=> world.calmFactor = 1, 1200); }
});

/* expose a tiny API for potential embedding (optional) */
window.relaxWater = {
  addBoat: addBoatAt,
  calm: ()=> { world.calmFactor=0.2; setTimeout(()=> world.calmFactor=1,1200); },
  wind: ()=> { world.wind += (Math.random()>0.5?1:-1) * (0.35 + Math.random()*0.6); }
};
</script>
</body>
</html>